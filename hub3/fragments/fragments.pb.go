// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hub3/fragments/fragments.proto

/*
Package fragments is a generated protocol buffer package.

It is generated from these files:
	hub3/fragments/fragments.proto

It has these top-level messages:
	FragmentResponse
	FragmentRequest
	Fragment
*/
package fragments

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ObjectType int32

const (
	ObjectType_RESOURCE ObjectType = 0
	ObjectType_LITERAL  ObjectType = 1
)

var ObjectType_name = map[int32]string{
	0: "RESOURCE",
	1: "LITERAL",
}
var ObjectType_value = map[string]int32{
	"RESOURCE": 0,
	"LITERAL":  1,
}

func (x ObjectType) String() string {
	return proto.EnumName(ObjectType_name, int32(x))
}
func (ObjectType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ObjectXSDType int32

const (
	ObjectXSDType_STRING             ObjectXSDType = 0
	ObjectXSDType_BOOLEAN            ObjectXSDType = 1
	ObjectXSDType_DECIMAL            ObjectXSDType = 2
	ObjectXSDType_FLOAT              ObjectXSDType = 3
	ObjectXSDType_DOUBLE             ObjectXSDType = 4
	ObjectXSDType_DATETIME           ObjectXSDType = 5
	ObjectXSDType_TIME               ObjectXSDType = 6
	ObjectXSDType_DATE               ObjectXSDType = 7
	ObjectXSDType_GYEARMONTH         ObjectXSDType = 8
	ObjectXSDType_GYEAR              ObjectXSDType = 9
	ObjectXSDType_GMONTHDAY          ObjectXSDType = 10
	ObjectXSDType_GDAY               ObjectXSDType = 11
	ObjectXSDType_GMONTH             ObjectXSDType = 12
	ObjectXSDType_HEXBINARY          ObjectXSDType = 13
	ObjectXSDType_BASE64BINARY       ObjectXSDType = 14
	ObjectXSDType_ANYURI             ObjectXSDType = 15
	ObjectXSDType_NORMALIZEDSTRING   ObjectXSDType = 16
	ObjectXSDType_TOKEN              ObjectXSDType = 17
	ObjectXSDType_LANGUAGE           ObjectXSDType = 18
	ObjectXSDType_NMTOKEN            ObjectXSDType = 19
	ObjectXSDType_NAME               ObjectXSDType = 20
	ObjectXSDType_NCNAME             ObjectXSDType = 21
	ObjectXSDType_INTEGER            ObjectXSDType = 22
	ObjectXSDType_NONPOSITIVEINTEGER ObjectXSDType = 23
	ObjectXSDType_NEGATIVEINTEGER    ObjectXSDType = 24
	ObjectXSDType_LONG               ObjectXSDType = 25
	ObjectXSDType_INT                ObjectXSDType = 26
	ObjectXSDType_SHORT              ObjectXSDType = 27
	ObjectXSDType_BYTE               ObjectXSDType = 28
	ObjectXSDType_NONNEGATIVEINTEGER ObjectXSDType = 29
	ObjectXSDType_UNSIGNEDLONG       ObjectXSDType = 30
	ObjectXSDType_UNSIGNEDINT        ObjectXSDType = 31
	ObjectXSDType_UNSIGNEDSHORT      ObjectXSDType = 32
	ObjectXSDType_UNSIGNEDBYTE       ObjectXSDType = 33
	ObjectXSDType_POSITIVEINTEGER    ObjectXSDType = 34
)

var ObjectXSDType_name = map[int32]string{
	0:  "STRING",
	1:  "BOOLEAN",
	2:  "DECIMAL",
	3:  "FLOAT",
	4:  "DOUBLE",
	5:  "DATETIME",
	6:  "TIME",
	7:  "DATE",
	8:  "GYEARMONTH",
	9:  "GYEAR",
	10: "GMONTHDAY",
	11: "GDAY",
	12: "GMONTH",
	13: "HEXBINARY",
	14: "BASE64BINARY",
	15: "ANYURI",
	16: "NORMALIZEDSTRING",
	17: "TOKEN",
	18: "LANGUAGE",
	19: "NMTOKEN",
	20: "NAME",
	21: "NCNAME",
	22: "INTEGER",
	23: "NONPOSITIVEINTEGER",
	24: "NEGATIVEINTEGER",
	25: "LONG",
	26: "INT",
	27: "SHORT",
	28: "BYTE",
	29: "NONNEGATIVEINTEGER",
	30: "UNSIGNEDLONG",
	31: "UNSIGNEDINT",
	32: "UNSIGNEDSHORT",
	33: "UNSIGNEDBYTE",
	34: "POSITIVEINTEGER",
}
var ObjectXSDType_value = map[string]int32{
	"STRING":             0,
	"BOOLEAN":            1,
	"DECIMAL":            2,
	"FLOAT":              3,
	"DOUBLE":             4,
	"DATETIME":           5,
	"TIME":               6,
	"DATE":               7,
	"GYEARMONTH":         8,
	"GYEAR":              9,
	"GMONTHDAY":          10,
	"GDAY":               11,
	"GMONTH":             12,
	"HEXBINARY":          13,
	"BASE64BINARY":       14,
	"ANYURI":             15,
	"NORMALIZEDSTRING":   16,
	"TOKEN":              17,
	"LANGUAGE":           18,
	"NMTOKEN":            19,
	"NAME":               20,
	"NCNAME":             21,
	"INTEGER":            22,
	"NONPOSITIVEINTEGER": 23,
	"NEGATIVEINTEGER":    24,
	"LONG":               25,
	"INT":                26,
	"SHORT":              27,
	"BYTE":               28,
	"NONNEGATIVEINTEGER": 29,
	"UNSIGNEDLONG":       30,
	"UNSIGNEDINT":        31,
	"UNSIGNEDSHORT":      32,
	"UNSIGNEDBYTE":       33,
	"POSITIVEINTEGER":    34,
}

func (x ObjectXSDType) String() string {
	return proto.EnumName(ObjectXSDType_name, int32(x))
}
func (ObjectXSDType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type FragmentResponse struct {
	Request   *FragmentRequest `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
	NrTriples int32            `protobuf:"varint,2,opt,name=nrTriples" json:"nrTriples,omitempty"`
	Page      int32            `protobuf:"varint,3,opt,name=page" json:"page,omitempty"`
	Fragments []*Fragment      `protobuf:"bytes,4,rep,name=fragments" json:"fragments,omitempty"`
}

func (m *FragmentResponse) Reset()                    { *m = FragmentResponse{} }
func (m *FragmentResponse) String() string            { return proto.CompactTextString(m) }
func (*FragmentResponse) ProtoMessage()               {}
func (*FragmentResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FragmentResponse) GetRequest() *FragmentRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FragmentResponse) GetNrTriples() int32 {
	if m != nil {
		return m.NrTriples
	}
	return 0
}

func (m *FragmentResponse) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FragmentResponse) GetFragments() []*Fragment {
	if m != nil {
		return m.Fragments
	}
	return nil
}

type FragmentRequest struct {
	Subject   string `protobuf:"bytes,1,opt,name=subject" json:"subject,omitempty"`
	Predicate string `protobuf:"bytes,2,opt,name=predicate" json:"predicate,omitempty"`
	Object    string `protobuf:"bytes,3,opt,name=object" json:"object,omitempty"`
	Page      int32  `protobuf:"varint,4,opt,name=page" json:"page,omitempty"`
}

func (m *FragmentRequest) Reset()                    { *m = FragmentRequest{} }
func (m *FragmentRequest) String() string            { return proto.CompactTextString(m) }
func (*FragmentRequest) ProtoMessage()               {}
func (*FragmentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FragmentRequest) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *FragmentRequest) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *FragmentRequest) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

func (m *FragmentRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

type Fragment struct {
	Spec          string        `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	Revision      int32         `protobuf:"varint,2,opt,name=revision" json:"revision,omitempty"`
	NamedGraphURI string        `protobuf:"bytes,3,opt,name=NamedGraphURI" json:"NamedGraphURI,omitempty"`
	Subject       string        `protobuf:"bytes,4,opt,name=subject" json:"subject,omitempty"`
	Predicate     string        `protobuf:"bytes,5,opt,name=predicate" json:"predicate,omitempty"`
	Object        string        `protobuf:"bytes,6,opt,name=object" json:"object,omitempty"`
	Language      string        `protobuf:"bytes,7,opt,name=language" json:"language,omitempty"`
	ObjectType    ObjectType    `protobuf:"varint,8,opt,name=objectType,enum=fragments.ObjectType" json:"objectType,omitempty"`
	DataType      ObjectXSDType `protobuf:"varint,9,opt,name=dataType,enum=fragments.ObjectXSDType" json:"dataType,omitempty"`
}

func (m *Fragment) Reset()                    { *m = Fragment{} }
func (m *Fragment) String() string            { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()               {}
func (*Fragment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Fragment) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *Fragment) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Fragment) GetNamedGraphURI() string {
	if m != nil {
		return m.NamedGraphURI
	}
	return ""
}

func (m *Fragment) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Fragment) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *Fragment) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

func (m *Fragment) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Fragment) GetObjectType() ObjectType {
	if m != nil {
		return m.ObjectType
	}
	return ObjectType_RESOURCE
}

func (m *Fragment) GetDataType() ObjectXSDType {
	if m != nil {
		return m.DataType
	}
	return ObjectXSDType_STRING
}

func init() {
	proto.RegisterType((*FragmentResponse)(nil), "fragments.FragmentResponse")
	proto.RegisterType((*FragmentRequest)(nil), "fragments.FragmentRequest")
	proto.RegisterType((*Fragment)(nil), "fragments.Fragment")
	proto.RegisterEnum("fragments.ObjectType", ObjectType_name, ObjectType_value)
	proto.RegisterEnum("fragments.ObjectXSDType", ObjectXSDType_name, ObjectXSDType_value)
}

func init() { proto.RegisterFile("hub3/fragments/fragments.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 674 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x5d, 0x4f, 0xdb, 0x48,
	0x14, 0xdd, 0x90, 0x2f, 0xfb, 0x86, 0x90, 0xe1, 0xf2, 0xb1, 0xde, 0xc0, 0xb2, 0x59, 0xb4, 0xd2,
	0x46, 0x3c, 0x50, 0x35, 0xd0, 0xbe, 0x4f, 0xc8, 0x60, 0xac, 0x3a, 0xe3, 0x6a, 0xec, 0x54, 0xa4,
	0x6f, 0x26, 0x4c, 0x21, 0x15, 0x24, 0xae, 0x9d, 0x20, 0xf5, 0xbd, 0x7f, 0xa7, 0x3f, 0xa0, 0xff,
	0xae, 0x9a, 0xb1, 0x13, 0x07, 0x4a, 0x79, 0xbb, 0xf7, 0xdc, 0x73, 0xcf, 0x3d, 0xc7, 0x92, 0x07,
	0x0e, 0x6e, 0xe7, 0x57, 0x27, 0xaf, 0x3e, 0xc5, 0xe1, 0xcd, 0xbd, 0x9c, 0xcc, 0x92, 0xbc, 0x3a,
	0x8e, 0xe2, 0xe9, 0x6c, 0x8a, 0xe6, 0x12, 0x38, 0xfc, 0x5e, 0x00, 0x72, 0x9e, 0x75, 0x42, 0x26,
	0xd1, 0x74, 0x92, 0x48, 0x3c, 0x85, 0x6a, 0x2c, 0xbf, 0xcc, 0x65, 0x32, 0xb3, 0x0a, 0xad, 0x42,
	0xbb, 0xd6, 0x69, 0x1e, 0xe7, 0x12, 0x39, 0x5b, 0x33, 0xc4, 0x82, 0x8a, 0xfb, 0x60, 0x4e, 0xe2,
	0x20, 0x1e, 0x47, 0x77, 0x32, 0xb1, 0xd6, 0x5a, 0x85, 0x76, 0x59, 0xe4, 0x00, 0x22, 0x94, 0xa2,
	0xf0, 0x46, 0x5a, 0x45, 0x3d, 0xd0, 0x35, 0xbe, 0x86, 0xdc, 0x89, 0x55, 0x6a, 0x15, 0xdb, 0xb5,
	0xce, 0xd6, 0x73, 0x97, 0x56, 0xfc, 0xce, 0xa1, 0xf1, 0xc4, 0x00, 0x5a, 0x50, 0x4d, 0xe6, 0x57,
	0x9f, 0xe5, 0x28, 0x75, 0x6b, 0x8a, 0x45, 0xab, 0x1c, 0x45, 0xb1, 0xbc, 0x1e, 0x8f, 0xc2, 0x99,
	0xd4, 0x8e, 0x4c, 0x91, 0x03, 0xb8, 0x0b, 0x95, 0x69, 0xba, 0x56, 0xd4, 0xa3, 0xac, 0x5b, 0x3a,
	0x2d, 0xe5, 0x4e, 0x0f, 0x7f, 0xac, 0x81, 0xb1, 0xb8, 0xab, 0x08, 0x49, 0x24, 0x47, 0xd9, 0x35,
	0x5d, 0x63, 0x13, 0x8c, 0x58, 0x3e, 0x8c, 0x93, 0xf1, 0x74, 0x92, 0x65, 0x5f, 0xf6, 0xf8, 0x1f,
	0xd4, 0x79, 0x78, 0x2f, 0xaf, 0xed, 0x38, 0x8c, 0x6e, 0x07, 0xc2, 0xc9, 0xee, 0x3d, 0x06, 0x57,
	0x63, 0x94, 0x5e, 0x88, 0x51, 0xfe, 0x7d, 0x8c, 0xca, 0xa3, 0x18, 0x4d, 0x30, 0xee, 0xc2, 0xc9,
	0xcd, 0x5c, 0x45, 0xa9, 0xea, 0xc9, 0xb2, 0xc7, 0x37, 0x00, 0x29, 0x2b, 0xf8, 0x1a, 0x49, 0xcb,
	0x68, 0x15, 0xda, 0x1b, 0x9d, 0x9d, 0x95, 0x2f, 0xef, 0x2d, 0x87, 0x62, 0x85, 0x88, 0xa7, 0x60,
	0x5c, 0x87, 0xb3, 0x50, 0x2f, 0x99, 0x7a, 0xc9, 0xfa, 0x65, 0xe9, 0xd2, 0xef, 0xe9, 0xbd, 0x25,
	0xf3, 0xe8, 0x7f, 0x80, 0x5c, 0x0f, 0xd7, 0xc1, 0x10, 0xcc, 0xf7, 0x06, 0xe2, 0x8c, 0x91, 0x3f,
	0xb0, 0x06, 0x55, 0xd7, 0x09, 0x98, 0xa0, 0x2e, 0x29, 0x1c, 0x7d, 0x2b, 0x41, 0xfd, 0x91, 0x08,
	0x02, 0x54, 0xfc, 0x40, 0x38, 0xdc, 0x4e, 0xa9, 0x5d, 0xcf, 0x73, 0x19, 0xe5, 0xa4, 0xa0, 0x9a,
	0x1e, 0x3b, 0x73, 0xfa, 0xd4, 0x25, 0x6b, 0x68, 0x42, 0xf9, 0xdc, 0xf5, 0x68, 0x40, 0x8a, 0x6a,
	0xa1, 0xe7, 0x0d, 0xba, 0x2e, 0x23, 0x25, 0x75, 0xa9, 0x47, 0x03, 0x16, 0x38, 0x7d, 0x46, 0xca,
	0x68, 0x40, 0x49, 0x57, 0x15, 0x55, 0x29, 0x9c, 0x54, 0x71, 0x03, 0xc0, 0x1e, 0x32, 0x2a, 0xfa,
	0x1e, 0x0f, 0x2e, 0x88, 0xa1, 0x84, 0x74, 0x4f, 0x4c, 0xac, 0x83, 0x69, 0x6b, 0xb8, 0x47, 0x87,
	0x04, 0xd4, 0x8e, 0xad, 0xaa, 0x9a, 0xba, 0x90, 0x0e, 0xc8, 0xba, 0x22, 0x5d, 0xb0, 0xcb, 0xae,
	0xc3, 0xa9, 0x18, 0x92, 0x3a, 0x12, 0x58, 0xef, 0x52, 0x9f, 0xbd, 0x3d, 0xcd, 0x90, 0x0d, 0x45,
	0xa6, 0x7c, 0x38, 0x10, 0x0e, 0x69, 0xe0, 0x36, 0x10, 0xee, 0x89, 0x3e, 0x75, 0x9d, 0x8f, 0xac,
	0x97, 0xa5, 0x22, 0xea, 0x64, 0xe0, 0xbd, 0x63, 0x9c, 0x6c, 0x2a, 0xbf, 0x2e, 0xe5, 0xf6, 0x80,
	0xda, 0x8c, 0xa0, 0x4a, 0xc8, 0xfb, 0xe9, 0x68, 0x4b, 0x9d, 0xe7, 0xb4, 0xcf, 0xc8, 0xb6, 0x52,
	0xe4, 0x67, 0xba, 0xde, 0x51, 0x14, 0x87, 0x07, 0xcc, 0x66, 0x82, 0xec, 0xe2, 0x2e, 0x20, 0xf7,
	0xf8, 0x7b, 0xcf, 0x77, 0x02, 0xe7, 0x03, 0x5b, 0xe0, 0x7f, 0xe2, 0x16, 0x34, 0x38, 0xb3, 0xe9,
	0x2a, 0x68, 0x29, 0x3d, 0xd7, 0xe3, 0x36, 0xf9, 0x0b, 0xab, 0x50, 0x74, 0x78, 0x40, 0x9a, 0xca,
	0x88, 0x7f, 0xe1, 0x89, 0x80, 0xec, 0xa9, 0x69, 0x77, 0x18, 0x30, 0xb2, 0x9f, 0x89, 0x3e, 0xdd,
	0xff, 0x5b, 0x25, 0x1d, 0x70, 0xdf, 0xb1, 0x39, 0xeb, 0x69, 0x9d, 0x03, 0x6c, 0x40, 0x6d, 0x81,
	0x28, 0xbd, 0x7f, 0x70, 0x13, 0xea, 0x0b, 0x20, 0xd5, 0x6d, 0xad, 0x6e, 0x69, 0xfd, 0x7f, 0x95,
	0xb9, 0xa7, 0x8e, 0x0f, 0x3b, 0x41, 0xfe, 0x8b, 0xfb, 0x32, 0x7e, 0x18, 0x8f, 0x24, 0x52, 0xa8,
	0xf8, 0x32, 0x8c, 0x47, 0xb7, 0xf8, 0xc2, 0x4b, 0xd4, 0xdc, 0x7b, 0x76, 0x96, 0xbe, 0x69, 0x57,
	0x15, 0xfd, 0xf4, 0x9d, 0xfc, 0x0c, 0x00, 0x00, 0xff, 0xff, 0xa8, 0xe8, 0xfc, 0x67, 0x1c, 0x05,
	0x00, 0x00,
}
