// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hub3/fragments/fragments.proto

/*
Package fragments is a generated protocol buffer package.

It is generated from these files:
	hub3/fragments/fragments.proto

It has these top-level messages:
	FragmentSearchResponse
	FragmentUpdateResponse
	FragmentError
	FragmentRequest
	FragmentGraph
	Fragment
*/
package fragments

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ObjectType int32

const (
	ObjectType_RESOURCE ObjectType = 0
	ObjectType_LITERAL  ObjectType = 1
)

var ObjectType_name = map[int32]string{
	0: "RESOURCE",
	1: "LITERAL",
}
var ObjectType_value = map[string]int32{
	"RESOURCE": 0,
	"LITERAL":  1,
}

func (x ObjectType) String() string {
	return proto.EnumName(ObjectType_name, int32(x))
}
func (ObjectType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ObjectXSDType int32

const (
	ObjectXSDType_STRING             ObjectXSDType = 0
	ObjectXSDType_BOOLEAN            ObjectXSDType = 1
	ObjectXSDType_DECIMAL            ObjectXSDType = 2
	ObjectXSDType_FLOAT              ObjectXSDType = 3
	ObjectXSDType_DOUBLE             ObjectXSDType = 4
	ObjectXSDType_DATETIME           ObjectXSDType = 5
	ObjectXSDType_TIME               ObjectXSDType = 6
	ObjectXSDType_DATE               ObjectXSDType = 7
	ObjectXSDType_GYEARMONTH         ObjectXSDType = 8
	ObjectXSDType_GYEAR              ObjectXSDType = 9
	ObjectXSDType_GMONTHDAY          ObjectXSDType = 10
	ObjectXSDType_GDAY               ObjectXSDType = 11
	ObjectXSDType_GMONTH             ObjectXSDType = 12
	ObjectXSDType_HEXBINARY          ObjectXSDType = 13
	ObjectXSDType_BASE64BINARY       ObjectXSDType = 14
	ObjectXSDType_ANYURI             ObjectXSDType = 15
	ObjectXSDType_NORMALIZEDSTRING   ObjectXSDType = 16
	ObjectXSDType_TOKEN              ObjectXSDType = 17
	ObjectXSDType_LANGUAGE           ObjectXSDType = 18
	ObjectXSDType_NMTOKEN            ObjectXSDType = 19
	ObjectXSDType_NAME               ObjectXSDType = 20
	ObjectXSDType_NCNAME             ObjectXSDType = 21
	ObjectXSDType_INTEGER            ObjectXSDType = 22
	ObjectXSDType_NONPOSITIVEINTEGER ObjectXSDType = 23
	ObjectXSDType_NEGATIVEINTEGER    ObjectXSDType = 24
	ObjectXSDType_LONG               ObjectXSDType = 25
	ObjectXSDType_INT                ObjectXSDType = 26
	ObjectXSDType_SHORT              ObjectXSDType = 27
	ObjectXSDType_BYTE               ObjectXSDType = 28
	ObjectXSDType_NONNEGATIVEINTEGER ObjectXSDType = 29
	ObjectXSDType_UNSIGNEDLONG       ObjectXSDType = 30
	ObjectXSDType_UNSIGNEDINT        ObjectXSDType = 31
	ObjectXSDType_UNSIGNEDSHORT      ObjectXSDType = 32
	ObjectXSDType_UNSIGNEDBYTE       ObjectXSDType = 33
	ObjectXSDType_POSITIVEINTEGER    ObjectXSDType = 34
)

var ObjectXSDType_name = map[int32]string{
	0:  "STRING",
	1:  "BOOLEAN",
	2:  "DECIMAL",
	3:  "FLOAT",
	4:  "DOUBLE",
	5:  "DATETIME",
	6:  "TIME",
	7:  "DATE",
	8:  "GYEARMONTH",
	9:  "GYEAR",
	10: "GMONTHDAY",
	11: "GDAY",
	12: "GMONTH",
	13: "HEXBINARY",
	14: "BASE64BINARY",
	15: "ANYURI",
	16: "NORMALIZEDSTRING",
	17: "TOKEN",
	18: "LANGUAGE",
	19: "NMTOKEN",
	20: "NAME",
	21: "NCNAME",
	22: "INTEGER",
	23: "NONPOSITIVEINTEGER",
	24: "NEGATIVEINTEGER",
	25: "LONG",
	26: "INT",
	27: "SHORT",
	28: "BYTE",
	29: "NONNEGATIVEINTEGER",
	30: "UNSIGNEDLONG",
	31: "UNSIGNEDINT",
	32: "UNSIGNEDSHORT",
	33: "UNSIGNEDBYTE",
	34: "POSITIVEINTEGER",
}
var ObjectXSDType_value = map[string]int32{
	"STRING":             0,
	"BOOLEAN":            1,
	"DECIMAL":            2,
	"FLOAT":              3,
	"DOUBLE":             4,
	"DATETIME":           5,
	"TIME":               6,
	"DATE":               7,
	"GYEARMONTH":         8,
	"GYEAR":              9,
	"GMONTHDAY":          10,
	"GDAY":               11,
	"GMONTH":             12,
	"HEXBINARY":          13,
	"BASE64BINARY":       14,
	"ANYURI":             15,
	"NORMALIZEDSTRING":   16,
	"TOKEN":              17,
	"LANGUAGE":           18,
	"NMTOKEN":            19,
	"NAME":               20,
	"NCNAME":             21,
	"INTEGER":            22,
	"NONPOSITIVEINTEGER": 23,
	"NEGATIVEINTEGER":    24,
	"LONG":               25,
	"INT":                26,
	"SHORT":              27,
	"BYTE":               28,
	"NONNEGATIVEINTEGER": 29,
	"UNSIGNEDLONG":       30,
	"UNSIGNEDINT":        31,
	"UNSIGNEDSHORT":      32,
	"UNSIGNEDBYTE":       33,
	"POSITIVEINTEGER":    34,
}

func (x ObjectXSDType) String() string {
	return proto.EnumName(ObjectXSDType_name, int32(x))
}
func (ObjectXSDType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type RecordType int32

const (
	RecordType_NARTHEX    RecordType = 0
	RecordType_SCHEMA     RecordType = 1
	RecordType_VOCABULARY RecordType = 2
	RecordType_SOURCE     RecordType = 3
	RecordType_CACHE      RecordType = 4
)

var RecordType_name = map[int32]string{
	0: "NARTHEX",
	1: "SCHEMA",
	2: "VOCABULARY",
	3: "SOURCE",
	4: "CACHE",
}
var RecordType_value = map[string]int32{
	"NARTHEX":    0,
	"SCHEMA":     1,
	"VOCABULARY": 2,
	"SOURCE":     3,
	"CACHE":      4,
}

func (x RecordType) String() string {
	return proto.EnumName(RecordType_name, int32(x))
}
func (RecordType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type FragmentSearchResponse struct {
	Request   *FragmentRequest `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
	NrTriples int32            `protobuf:"varint,2,opt,name=nrTriples" json:"nrTriples,omitempty"`
	Page      int32            `protobuf:"varint,3,opt,name=page" json:"page,omitempty"`
	Fragments []*Fragment      `protobuf:"bytes,4,rep,name=fragments" json:"fragments,omitempty"`
}

func (m *FragmentSearchResponse) Reset()                    { *m = FragmentSearchResponse{} }
func (m *FragmentSearchResponse) String() string            { return proto.CompactTextString(m) }
func (*FragmentSearchResponse) ProtoMessage()               {}
func (*FragmentSearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FragmentSearchResponse) GetRequest() *FragmentRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *FragmentSearchResponse) GetNrTriples() int32 {
	if m != nil {
		return m.NrTriples
	}
	return 0
}

func (m *FragmentSearchResponse) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FragmentSearchResponse) GetFragments() []*Fragment {
	if m != nil {
		return m.Fragments
	}
	return nil
}

type FragmentUpdateResponse struct {
	GraphsStored int32            `protobuf:"varint,1,opt,name=graphsStored" json:"graphsStored,omitempty"`
	Spec         string           `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	HasErrors    bool             `protobuf:"varint,3,opt,name=hasErrors" json:"hasErrors,omitempty"`
	Errors       []*FragmentError `protobuf:"bytes,4,rep,name=errors" json:"errors,omitempty"`
}

func (m *FragmentUpdateResponse) Reset()                    { *m = FragmentUpdateResponse{} }
func (m *FragmentUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*FragmentUpdateResponse) ProtoMessage()               {}
func (*FragmentUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FragmentUpdateResponse) GetGraphsStored() int32 {
	if m != nil {
		return m.GraphsStored
	}
	return 0
}

func (m *FragmentUpdateResponse) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *FragmentUpdateResponse) GetHasErrors() bool {
	if m != nil {
		return m.HasErrors
	}
	return false
}

func (m *FragmentUpdateResponse) GetErrors() []*FragmentError {
	if m != nil {
		return m.Errors
	}
	return nil
}

type FragmentError struct {
}

func (m *FragmentError) Reset()                    { *m = FragmentError{} }
func (m *FragmentError) String() string            { return proto.CompactTextString(m) }
func (*FragmentError) ProtoMessage()               {}
func (*FragmentError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type FragmentRequest struct {
	Subject   string `protobuf:"bytes,1,opt,name=subject" json:"subject,omitempty"`
	Predicate string `protobuf:"bytes,2,opt,name=predicate" json:"predicate,omitempty"`
	Object    string `protobuf:"bytes,3,opt,name=object" json:"object,omitempty"`
	Page      int32  `protobuf:"varint,4,opt,name=page" json:"page,omitempty"`
	Language  string `protobuf:"bytes,5,opt,name=language" json:"language,omitempty"`
	OrgID     string `protobuf:"bytes,6,opt,name=orgID" json:"orgID,omitempty"`
	Graph     string `protobuf:"bytes,7,opt,name=graph" json:"graph,omitempty"`
	Spec      string `protobuf:"bytes,8,opt,name=spec" json:"spec,omitempty"`
}

func (m *FragmentRequest) Reset()                    { *m = FragmentRequest{} }
func (m *FragmentRequest) String() string            { return proto.CompactTextString(m) }
func (*FragmentRequest) ProtoMessage()               {}
func (*FragmentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FragmentRequest) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *FragmentRequest) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *FragmentRequest) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

func (m *FragmentRequest) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FragmentRequest) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *FragmentRequest) GetOrgID() string {
	if m != nil {
		return m.OrgID
	}
	return ""
}

func (m *FragmentRequest) GetGraph() string {
	if m != nil {
		return m.Graph
	}
	return ""
}

func (m *FragmentRequest) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

type FragmentGraph struct {
	OrgID         string      `protobuf:"bytes,1,opt,name=orgID" json:"orgID,omitempty"`
	Spec          string      `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Revision      int32       `protobuf:"varint,3,opt,name=revision" json:"revision,omitempty"`
	HubID         string      `protobuf:"bytes,4,opt,name=hubID" json:"hubID,omitempty"`
	EntryURI      string      `protobuf:"bytes,5,opt,name=entryURI" json:"entryURI,omitempty"`
	NamedGraphURI string      `protobuf:"bytes,6,opt,name=namedGraphURI" json:"namedGraphURI,omitempty"`
	RDF           []byte      `protobuf:"bytes,7,opt,name=RDF,proto3" json:"RDF,omitempty"`
	RdfMimeType   string      `protobuf:"bytes,8,opt,name=rdfMimeType" json:"rdfMimeType,omitempty"`
	RecordType    RecordType  `protobuf:"varint,9,opt,name=recordType,enum=fragments.RecordType" json:"recordType,omitempty"`
	Fragments     []*Fragment `protobuf:"bytes,10,rep,name=fragments" json:"fragments,omitempty"`
	Tags          []string    `protobuf:"bytes,11,rep,name=tags" json:"tags,omitempty"`
}

func (m *FragmentGraph) Reset()                    { *m = FragmentGraph{} }
func (m *FragmentGraph) String() string            { return proto.CompactTextString(m) }
func (*FragmentGraph) ProtoMessage()               {}
func (*FragmentGraph) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FragmentGraph) GetOrgID() string {
	if m != nil {
		return m.OrgID
	}
	return ""
}

func (m *FragmentGraph) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *FragmentGraph) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *FragmentGraph) GetHubID() string {
	if m != nil {
		return m.HubID
	}
	return ""
}

func (m *FragmentGraph) GetEntryURI() string {
	if m != nil {
		return m.EntryURI
	}
	return ""
}

func (m *FragmentGraph) GetNamedGraphURI() string {
	if m != nil {
		return m.NamedGraphURI
	}
	return ""
}

func (m *FragmentGraph) GetRDF() []byte {
	if m != nil {
		return m.RDF
	}
	return nil
}

func (m *FragmentGraph) GetRdfMimeType() string {
	if m != nil {
		return m.RdfMimeType
	}
	return ""
}

func (m *FragmentGraph) GetRecordType() RecordType {
	if m != nil {
		return m.RecordType
	}
	return RecordType_NARTHEX
}

func (m *FragmentGraph) GetFragments() []*Fragment {
	if m != nil {
		return m.Fragments
	}
	return nil
}

func (m *FragmentGraph) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Fragment struct {
	// meta block
	OrgID    string `protobuf:"bytes,1,opt,name=orgID" json:"orgID,omitempty"`
	Spec     string `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Revision int32  `protobuf:"varint,3,opt,name=revision" json:"revision,omitempty"`
	HubID    string `protobuf:"bytes,4,opt,name=hubID" json:"hubID,omitempty"`
	// RDF core
	Subject           string        `protobuf:"bytes,5,opt,name=subject" json:"subject,omitempty"`
	SubjectClass      []string      `protobuf:"bytes,6,rep,name=subjectClass" json:"subjectClass,omitempty"`
	Predicate         string        `protobuf:"bytes,7,opt,name=predicate" json:"predicate,omitempty"`
	SearchLabel       string        `protobuf:"bytes,8,opt,name=searchLabel" json:"searchLabel,omitempty"`
	Object            string        `protobuf:"bytes,9,opt,name=object" json:"object,omitempty"`
	ObjectType        ObjectType    `protobuf:"varint,10,opt,name=objectType,enum=fragments.ObjectType" json:"objectType,omitempty"`
	Language          string        `protobuf:"bytes,11,opt,name=language" json:"language,omitempty"`
	ObjectContentType string        `protobuf:"bytes,12,opt,name=objectContentType" json:"objectContentType,omitempty"`
	DataType          ObjectXSDType `protobuf:"varint,13,opt,name=dataType,enum=fragments.ObjectXSDType" json:"dataType,omitempty"`
	XSDRaw            string        `protobuf:"bytes,14,opt,name=XSDRaw" json:"XSDRaw,omitempty"`
	ObjectTypeRaw     string        `protobuf:"bytes,29,opt,name=objectTypeRaw" json:"objectTypeRaw,omitempty"`
	NamedGraphURI     string        `protobuf:"bytes,15,opt,name=namedGraphURI" json:"namedGraphURI,omitempty"`
	Triple            string        `protobuf:"bytes,16,opt,name=triple" json:"triple,omitempty"`
	// RDF graph position
	Level                int32    `protobuf:"varint,17,opt,name=level" json:"level,omitempty"`
	ReferrerSubject      string   `protobuf:"bytes,18,opt,name=referrerSubject" json:"referrerSubject,omitempty"`
	ReferrerPredicate    string   `protobuf:"bytes,19,opt,name=referrerPredicate" json:"referrerPredicate,omitempty"`
	ReferrerSearchLabel  string   `protobuf:"bytes,20,opt,name=referrerSearchLabel" json:"referrerSearchLabel,omitempty"`
	ReferrerSubjectClass []string `protobuf:"bytes,21,rep,name=referrerSubjectClass" json:"referrerSubjectClass,omitempty"`
	// Content Index
	LatLong                   string `protobuf:"bytes,22,opt,name=latLong" json:"latLong,omitempty"`
	Date                      string `protobuf:"bytes,23,opt,name=date" json:"date,omitempty"`
	DateRange                 string `protobuf:"bytes,24,opt,name=dateRange" json:"dateRange,omitempty"`
	Integer                   int32  `protobuf:"varint,25,opt,name=integer" json:"integer,omitempty"`
	IntegerRange              int32  `protobuf:"varint,26,opt,name=integerRange" json:"integerRange,omitempty"`
	ReferrerResourceSortOrder int32  `protobuf:"varint,27,opt,name=referrerResourceSortOrder" json:"referrerResourceSortOrder,omitempty"`
	// content tags
	// example values linkGraphExternal prefLabel linkDomainExternal thumbnail date
	Tags []string `protobuf:"bytes,28,rep,name=tags" json:"tags,omitempty"`
}

func (m *Fragment) Reset()                    { *m = Fragment{} }
func (m *Fragment) String() string            { return proto.CompactTextString(m) }
func (*Fragment) ProtoMessage()               {}
func (*Fragment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Fragment) GetOrgID() string {
	if m != nil {
		return m.OrgID
	}
	return ""
}

func (m *Fragment) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *Fragment) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Fragment) GetHubID() string {
	if m != nil {
		return m.HubID
	}
	return ""
}

func (m *Fragment) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Fragment) GetSubjectClass() []string {
	if m != nil {
		return m.SubjectClass
	}
	return nil
}

func (m *Fragment) GetPredicate() string {
	if m != nil {
		return m.Predicate
	}
	return ""
}

func (m *Fragment) GetSearchLabel() string {
	if m != nil {
		return m.SearchLabel
	}
	return ""
}

func (m *Fragment) GetObject() string {
	if m != nil {
		return m.Object
	}
	return ""
}

func (m *Fragment) GetObjectType() ObjectType {
	if m != nil {
		return m.ObjectType
	}
	return ObjectType_RESOURCE
}

func (m *Fragment) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Fragment) GetObjectContentType() string {
	if m != nil {
		return m.ObjectContentType
	}
	return ""
}

func (m *Fragment) GetDataType() ObjectXSDType {
	if m != nil {
		return m.DataType
	}
	return ObjectXSDType_STRING
}

func (m *Fragment) GetXSDRaw() string {
	if m != nil {
		return m.XSDRaw
	}
	return ""
}

func (m *Fragment) GetObjectTypeRaw() string {
	if m != nil {
		return m.ObjectTypeRaw
	}
	return ""
}

func (m *Fragment) GetNamedGraphURI() string {
	if m != nil {
		return m.NamedGraphURI
	}
	return ""
}

func (m *Fragment) GetTriple() string {
	if m != nil {
		return m.Triple
	}
	return ""
}

func (m *Fragment) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Fragment) GetReferrerSubject() string {
	if m != nil {
		return m.ReferrerSubject
	}
	return ""
}

func (m *Fragment) GetReferrerPredicate() string {
	if m != nil {
		return m.ReferrerPredicate
	}
	return ""
}

func (m *Fragment) GetReferrerSearchLabel() string {
	if m != nil {
		return m.ReferrerSearchLabel
	}
	return ""
}

func (m *Fragment) GetReferrerSubjectClass() []string {
	if m != nil {
		return m.ReferrerSubjectClass
	}
	return nil
}

func (m *Fragment) GetLatLong() string {
	if m != nil {
		return m.LatLong
	}
	return ""
}

func (m *Fragment) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *Fragment) GetDateRange() string {
	if m != nil {
		return m.DateRange
	}
	return ""
}

func (m *Fragment) GetInteger() int32 {
	if m != nil {
		return m.Integer
	}
	return 0
}

func (m *Fragment) GetIntegerRange() int32 {
	if m != nil {
		return m.IntegerRange
	}
	return 0
}

func (m *Fragment) GetReferrerResourceSortOrder() int32 {
	if m != nil {
		return m.ReferrerResourceSortOrder
	}
	return 0
}

func (m *Fragment) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
	proto.RegisterType((*FragmentSearchResponse)(nil), "fragments.FragmentSearchResponse")
	proto.RegisterType((*FragmentUpdateResponse)(nil), "fragments.FragmentUpdateResponse")
	proto.RegisterType((*FragmentError)(nil), "fragments.FragmentError")
	proto.RegisterType((*FragmentRequest)(nil), "fragments.FragmentRequest")
	proto.RegisterType((*FragmentGraph)(nil), "fragments.FragmentGraph")
	proto.RegisterType((*Fragment)(nil), "fragments.Fragment")
	proto.RegisterEnum("fragments.ObjectType", ObjectType_name, ObjectType_value)
	proto.RegisterEnum("fragments.ObjectXSDType", ObjectXSDType_name, ObjectXSDType_value)
	proto.RegisterEnum("fragments.RecordType", RecordType_name, RecordType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FragmentService service

type FragmentServiceClient interface {
	Search(ctx context.Context, in *FragmentRequest, opts ...grpc.CallOption) (*FragmentSearchResponse, error)
	Update(ctx context.Context, in *FragmentGraph, opts ...grpc.CallOption) (*FragmentUpdateResponse, error)
}

type fragmentServiceClient struct {
	cc *grpc.ClientConn
}

func NewFragmentServiceClient(cc *grpc.ClientConn) FragmentServiceClient {
	return &fragmentServiceClient{cc}
}

func (c *fragmentServiceClient) Search(ctx context.Context, in *FragmentRequest, opts ...grpc.CallOption) (*FragmentSearchResponse, error) {
	out := new(FragmentSearchResponse)
	err := grpc.Invoke(ctx, "/fragments.FragmentService/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fragmentServiceClient) Update(ctx context.Context, in *FragmentGraph, opts ...grpc.CallOption) (*FragmentUpdateResponse, error) {
	out := new(FragmentUpdateResponse)
	err := grpc.Invoke(ctx, "/fragments.FragmentService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FragmentService service

type FragmentServiceServer interface {
	Search(context.Context, *FragmentRequest) (*FragmentSearchResponse, error)
	Update(context.Context, *FragmentGraph) (*FragmentUpdateResponse, error)
}

func RegisterFragmentServiceServer(s *grpc.Server, srv FragmentServiceServer) {
	s.RegisterService(&_FragmentService_serviceDesc, srv)
}

func _FragmentService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FragmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FragmentServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fragments.FragmentService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FragmentServiceServer).Search(ctx, req.(*FragmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FragmentService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FragmentGraph)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FragmentServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fragments.FragmentService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FragmentServiceServer).Update(ctx, req.(*FragmentGraph))
	}
	return interceptor(ctx, in, info, handler)
}

var _FragmentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fragments.FragmentService",
	HandlerType: (*FragmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _FragmentService_Search_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FragmentService_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hub3/fragments/fragments.proto",
}

func init() { proto.RegisterFile("hub3/fragments/fragments.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1181 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x8e, 0xac, 0xf3, 0x48, 0xb2, 0xd6, 0x6b, 0xc7, 0x61, 0x9c, 0xc3, 0xaf, 0x08, 0x3f, 0x50,
	0x23, 0x28, 0xd2, 0xd4, 0x49, 0x7a, 0xd5, 0x1b, 0x5a, 0xda, 0xc8, 0x44, 0x29, 0x32, 0x58, 0x52,
	0x81, 0xdd, 0x3b, 0x5a, 0xda, 0xc8, 0x2a, 0x14, 0x51, 0x5d, 0xd2, 0x29, 0x72, 0xdf, 0x07, 0x69,
	0x9f, 0xa1, 0x4f, 0xd2, 0x27, 0xc8, 0xab, 0x14, 0xb3, 0x4b, 0x52, 0xa4, 0xac, 0x16, 0xbd, 0xe9,
	0xdd, 0xcc, 0x37, 0x87, 0xfd, 0x66, 0xf6, 0x13, 0xb5, 0xf0, 0xf4, 0xe6, 0xf6, 0xfa, 0xd5, 0x37,
	0x1f, 0x64, 0x30, 0xff, 0x28, 0x56, 0x71, 0xb4, 0xb1, 0x5e, 0xac, 0x65, 0x18, 0x87, 0xb4, 0x99,
	0x01, 0xfd, 0x3f, 0x4a, 0x70, 0xfc, 0x36, 0xf1, 0x3c, 0x11, 0xc8, 0xe9, 0x0d, 0x17, 0xd1, 0x3a,
	0x5c, 0x45, 0x82, 0xbe, 0x86, 0xba, 0x14, 0x3f, 0xdf, 0x8a, 0x28, 0x36, 0x4a, 0xbd, 0xd2, 0x69,
	0xeb, 0xec, 0xe4, 0xc5, 0xa6, 0x51, 0x5a, 0xc3, 0x75, 0x06, 0x4f, 0x53, 0xe9, 0x63, 0x68, 0xae,
	0xa4, 0x2f, 0x17, 0xeb, 0xa5, 0x88, 0x8c, 0xbd, 0x5e, 0xe9, 0xb4, 0xca, 0x37, 0x00, 0xa5, 0x50,
	0x59, 0x07, 0x73, 0x61, 0x94, 0x55, 0x40, 0xd9, 0xf4, 0x5b, 0xd8, 0xf0, 0x31, 0x2a, 0xbd, 0xf2,
	0x69, 0xeb, 0xec, 0x70, 0xd7, 0x49, 0x39, 0xd6, 0xbf, 0xe5, 0x58, 0x4f, 0xd6, 0xb3, 0x20, 0x16,
	0x19, 0xeb, 0x3e, 0xb4, 0xe7, 0x32, 0x58, 0xdf, 0x44, 0x5e, 0x1c, 0x4a, 0x31, 0x53, 0xd4, 0xab,
	0xbc, 0x80, 0x21, 0x8b, 0x68, 0x2d, 0xa6, 0x8a, 0x5e, 0x93, 0x2b, 0x1b, 0x79, 0xdf, 0x04, 0x11,
	0x93, 0x32, 0x94, 0x91, 0xa2, 0xd7, 0xe0, 0x1b, 0x80, 0xbe, 0x84, 0x9a, 0xd0, 0x21, 0x4d, 0xd0,
	0xd8, 0x41, 0x50, 0xa5, 0xf2, 0x24, 0xaf, 0xdf, 0x85, 0x4e, 0x21, 0xd0, 0xff, 0xb3, 0x04, 0xdd,
	0xad, 0xad, 0x51, 0x03, 0xea, 0xd1, 0xed, 0xf5, 0x4f, 0x62, 0xaa, 0x57, 0xdc, 0xe4, 0xa9, 0x8b,
	0x74, 0xd6, 0x52, 0xcc, 0x16, 0xd3, 0x20, 0x16, 0x09, 0xcf, 0x0d, 0x40, 0x8f, 0xa1, 0x16, 0xea,
	0xb2, 0xb2, 0x0a, 0x25, 0x5e, 0xb6, 0xde, 0x4a, 0x6e, 0xbd, 0x27, 0xd0, 0x58, 0x06, 0xab, 0xf9,
	0x2d, 0xe2, 0x55, 0x95, 0x9d, 0xf9, 0xf4, 0x08, 0xaa, 0xa1, 0x9c, 0x5b, 0x43, 0xa3, 0xa6, 0x02,
	0xda, 0x41, 0x54, 0xad, 0xcb, 0xa8, 0x6b, 0x54, 0x39, 0xd9, 0xd2, 0x1a, 0x9b, 0xa5, 0xf5, 0xbf,
	0xec, 0x6d, 0xa6, 0x1c, 0xa9, 0xac, 0xac, 0x63, 0x29, 0xdf, 0x71, 0xd7, 0xc2, 0x4f, 0xa0, 0x21,
	0xc5, 0xa7, 0x45, 0xb4, 0x08, 0x57, 0x89, 0x1c, 0x32, 0x1f, 0xbb, 0xdc, 0xdc, 0x5e, 0x5b, 0x43,
	0x35, 0x48, 0x93, 0x6b, 0x07, 0x2b, 0xc4, 0x2a, 0x96, 0x9f, 0x27, 0xdc, 0x4a, 0x27, 0x49, 0x7d,
	0xfa, 0x7f, 0xe8, 0xac, 0x82, 0x8f, 0x62, 0xa6, 0x58, 0x60, 0x82, 0x9e, 0xa8, 0x08, 0x52, 0x02,
	0x65, 0x3e, 0x7c, 0xab, 0xe6, 0x6a, 0x73, 0x34, 0x69, 0x0f, 0x5a, 0x72, 0xf6, 0x61, 0xbc, 0xf8,
	0x28, 0xfc, 0xcf, 0x6b, 0x91, 0x0c, 0x97, 0x87, 0xe8, 0x1b, 0x00, 0x29, 0xa6, 0xa1, 0x9c, 0xa9,
	0x84, 0x66, 0xaf, 0x74, 0xba, 0x7f, 0x76, 0x3f, 0x77, 0xfd, 0x3c, 0x0b, 0xf2, 0x5c, 0x62, 0x51,
	0xd5, 0xf0, 0x6f, 0x54, 0x8d, 0x5b, 0x8a, 0x83, 0x79, 0x64, 0xb4, 0x7a, 0x65, 0xdc, 0x12, 0xda,
	0xfd, 0x2f, 0x75, 0x68, 0xa4, 0xb9, 0xff, 0xe9, 0x72, 0x73, 0x52, 0xac, 0x16, 0xa5, 0xd8, 0x87,
	0x76, 0x62, 0x0e, 0x96, 0x41, 0x14, 0x19, 0x35, 0x45, 0xaf, 0x80, 0x15, 0xe5, 0x5a, 0xdf, 0x96,
	0x6b, 0x0f, 0x5a, 0x91, 0xfa, 0xb6, 0xd8, 0xc1, 0xb5, 0x58, 0xa6, 0x4b, 0xce, 0x41, 0x39, 0x41,
	0x37, 0x0b, 0x82, 0x7e, 0x03, 0xa0, 0x2d, 0xb5, 0x7c, 0xb8, 0xb3, 0x7c, 0x37, 0x0b, 0xf2, 0x5c,
	0x62, 0x41, 0xf3, 0xad, 0x2d, 0xcd, 0x7f, 0x0d, 0x07, 0x3a, 0x73, 0x10, 0xae, 0x62, 0xb1, 0xd2,
	0x9d, 0xdb, 0x2a, 0xe9, 0x6e, 0x80, 0xbe, 0x86, 0xc6, 0x2c, 0x88, 0x03, 0x95, 0xd4, 0x51, 0xc7,
	0x1b, 0x77, 0x8e, 0xbf, 0xf4, 0x86, 0x8a, 0x41, 0x96, 0x89, 0xe3, 0x5c, 0x7a, 0x43, 0x1e, 0xfc,
	0x62, 0xec, 0xeb, 0x71, 0xb4, 0x87, 0x2a, 0xdd, 0xb0, 0xc4, 0xf0, 0x13, 0xad, 0xd2, 0x02, 0x78,
	0x57, 0xcb, 0xdd, 0x5d, 0x5a, 0x3e, 0x86, 0x5a, 0xac, 0xbe, 0xaa, 0x06, 0xd1, 0x67, 0x68, 0x0f,
	0xaf, 0x77, 0x29, 0x3e, 0x89, 0xa5, 0x71, 0xa0, 0xee, 0x5d, 0x3b, 0xf4, 0x14, 0xba, 0x52, 0x7c,
	0x10, 0x52, 0x0a, 0xe9, 0x25, 0xd7, 0x4c, 0x55, 0xd9, 0x36, 0x8c, 0xfb, 0x49, 0xa1, 0x77, 0xd9,
	0x95, 0x1e, 0xea, 0xfd, 0xdc, 0x09, 0xd0, 0x97, 0x70, 0x98, 0x35, 0xc8, 0x5d, 0xf1, 0x91, 0xca,
	0xdf, 0x15, 0xa2, 0x67, 0x70, 0xb4, 0x75, 0xa4, 0x96, 0xd5, 0x7d, 0x25, 0xab, 0x9d, 0x31, 0x14,
	0xe7, 0x32, 0x88, 0xed, 0x70, 0x35, 0x37, 0x8e, 0xb5, 0x38, 0x13, 0x17, 0xc5, 0x8f, 0x9f, 0x7f,
	0xe3, 0x81, 0x16, 0x3f, 0xda, 0x28, 0x46, 0xf5, 0x97, 0x10, 0xac, 0xe6, 0xc2, 0x30, 0xb4, 0x18,
	0x33, 0x00, 0x7b, 0x2d, 0x56, 0xb1, 0x98, 0x0b, 0x69, 0x3c, 0x54, 0x1b, 0x4a, 0x5d, 0x14, 0x7a,
	0x62, 0xea, 0xd2, 0x13, 0xfd, 0xd7, 0x91, 0xc7, 0xe8, 0xf7, 0xf0, 0x30, 0x65, 0xc8, 0x45, 0x14,
	0xde, 0xca, 0xa9, 0xf0, 0x42, 0x19, 0xbb, 0x72, 0x26, 0xa4, 0xf1, 0x48, 0x15, 0xfc, 0x7d, 0x42,
	0xf6, 0x0b, 0x7f, 0xbc, 0xf9, 0x85, 0x3f, 0xff, 0x0a, 0x60, 0xa3, 0x62, 0xda, 0x86, 0x06, 0x67,
	0x9e, 0x3b, 0xe1, 0x03, 0x46, 0xee, 0xd1, 0x16, 0xd4, 0x6d, 0xcb, 0x67, 0xdc, 0xb4, 0x49, 0xe9,
	0xf9, 0xaf, 0x15, 0xe8, 0x14, 0x04, 0x47, 0x01, 0x6a, 0x9e, 0xcf, 0x2d, 0x67, 0xa4, 0x53, 0xcf,
	0x5d, 0xd7, 0x66, 0xa6, 0x43, 0x4a, 0xe8, 0x0c, 0xd9, 0xc0, 0x1a, 0x9b, 0x36, 0xd9, 0xa3, 0x4d,
	0xa8, 0xbe, 0xb5, 0x5d, 0xd3, 0x27, 0x65, 0x2c, 0x18, 0xba, 0x93, 0x73, 0x9b, 0x91, 0x0a, 0x9e,
	0x34, 0x34, 0x7d, 0xe6, 0x5b, 0x63, 0x46, 0xaa, 0xb4, 0x01, 0x15, 0x65, 0xd5, 0xd0, 0x42, 0x9c,
	0xd4, 0xe9, 0x3e, 0xc0, 0xe8, 0x8a, 0x99, 0x7c, 0xec, 0x3a, 0xfe, 0x05, 0x69, 0x60, 0x23, 0xe5,
	0x93, 0x26, 0xed, 0x40, 0x73, 0xa4, 0xe0, 0xa1, 0x79, 0x45, 0x00, 0x6b, 0x46, 0x68, 0xb5, 0xf0,
	0x04, 0x1d, 0x20, 0x6d, 0x4c, 0xba, 0x60, 0x97, 0xe7, 0x96, 0x63, 0xf2, 0x2b, 0xd2, 0xa1, 0x04,
	0xda, 0xe7, 0xa6, 0xc7, 0xbe, 0x7b, 0x9d, 0x20, 0xfb, 0x98, 0x6c, 0x3a, 0x57, 0x13, 0x6e, 0x91,
	0x2e, 0x3d, 0x02, 0xe2, 0xb8, 0x7c, 0x6c, 0xda, 0xd6, 0x8f, 0x6c, 0x98, 0x4c, 0x45, 0xf0, 0x48,
	0xdf, 0xfd, 0x81, 0x39, 0xe4, 0x00, 0xf9, 0xda, 0xa6, 0x33, 0x9a, 0x98, 0x23, 0x46, 0x28, 0x4e,
	0xe8, 0x8c, 0x75, 0xe8, 0x10, 0x8f, 0x77, 0xcc, 0x31, 0x23, 0x47, 0xd8, 0xd1, 0x19, 0x28, 0xfb,
	0x3e, 0xa6, 0x58, 0x8e, 0xcf, 0x46, 0x8c, 0x93, 0x63, 0x7a, 0x0c, 0xd4, 0x71, 0x9d, 0x77, 0xae,
	0x67, 0xf9, 0xd6, 0x7b, 0x96, 0xe2, 0x0f, 0xe8, 0x21, 0x74, 0x1d, 0x36, 0x32, 0xf3, 0xa0, 0x81,
	0xfd, 0x6c, 0xd7, 0x19, 0x91, 0x87, 0xb4, 0x0e, 0x65, 0xcb, 0xf1, 0xc9, 0x09, 0x12, 0xf1, 0x2e,
	0x5c, 0xee, 0x93, 0x47, 0x18, 0x3d, 0xbf, 0xf2, 0x19, 0x79, 0x9c, 0x34, 0xdd, 0xae, 0x7f, 0x82,
	0x93, 0x4e, 0x1c, 0xcf, 0x1a, 0x39, 0x6c, 0xa8, 0xfa, 0x3c, 0xa5, 0x5d, 0x68, 0xa5, 0x08, 0xf6,
	0xfb, 0x1f, 0x3d, 0x80, 0x4e, 0x0a, 0xe8, 0xbe, 0xbd, 0x7c, 0x95, 0xea, 0xff, 0x0c, 0xc9, 0x6d,
	0x33, 0xee, 0x3f, 0xb7, 0x01, 0x36, 0x7f, 0x39, 0x6a, 0x0f, 0x26, 0xf7, 0x2f, 0xd8, 0x25, 0xb9,
	0xa7, 0xf4, 0x30, 0xb8, 0x60, 0x63, 0x93, 0x94, 0xf0, 0xf2, 0xde, 0xbb, 0x03, 0xf3, 0x7c, 0x62,
	0xe3, 0xae, 0xf7, 0x54, 0x4c, 0xcb, 0xaa, 0x8c, 0xc3, 0x0c, 0xcc, 0xc1, 0x05, 0x23, 0x95, 0xb3,
	0xdf, 0x73, 0xaf, 0x12, 0x4f, 0xc8, 0x4f, 0x8b, 0xa9, 0xa0, 0x23, 0xa8, 0xe9, 0x1f, 0x2c, 0xfd,
	0x87, 0x17, 0xdf, 0xc9, 0xb3, 0x1d, 0xb1, 0xad, 0x17, 0x24, 0x83, 0x9a, 0x7e, 0x9d, 0xd1, 0x5d,
	0xef, 0x25, 0xf5, 0x25, 0xdb, 0xd9, 0xa6, 0xf8, 0xa4, 0xbb, 0xae, 0xa9, 0x57, 0xeb, 0xab, 0xbf,
	0x02, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x27, 0x9e, 0xfc, 0xd7, 0x0a, 0x00, 0x00,
}
