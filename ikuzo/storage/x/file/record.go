package file

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"time"
)

//go:generate stringer -type=SourceFormat
type SourceFormat int

const (
	FormatRaw SourceFormat = iota
	FormatNTriples
	FormatEAD
)

var lineCommentSeparator = []byte("# !{")

// RecordSeparator is single-line json comment that separates Ntriple Records
// generated by Narthex.
type RecordSeparator struct {
	OrgID       string `json:"orgID"`
	DatasetID   string `json:"datasetID"`
	HubID       string `json:"hubID"`
	LocalID     string `json:"localID"`
	GraphURI    string `json:"graphURI"`
	ContentHash string `json:"contentHash"`
}

func (sep RecordSeparator) String() string {
	s, err := json.Marshal(sep)
	if err != nil {
		return "# unable to generate record separator string"
	}

	return "# !" + string(s)
}

func IsRecordSeparator(line []byte) bool {
	return bytes.HasPrefix(line, lineCommentSeparator)
}

func NewRecordSeparator(line []byte) (RecordSeparator, error) {
	var sep RecordSeparator
	line = bytes.TrimPrefix(line, []byte("# !"))
	if err := json.NewDecoder(bytes.NewReader(line)).Decode(&sep); err != nil {
		return sep, err
	}

	return sep, nil
}

func (sep RecordSeparator) newRecordPointer(fname, fhash string) *recordPointer {
	return &recordPointer{
		OrgID:        sep.OrgID,
		DatasetID:    sep.DatasetID,
		FileName:     fname,
		FileHash:     fhash,
		Offset:       0,
		Length:       0,
		HubID:        sep.HubID,
		LocalID:      sep.LocalID,
		RecordHash:   sep.ContentHash,
		GraphName:    sep.GraphURI,
		LastModified: time.Now(),
		Deleted:      false,
	}
}

func fileHash(r io.Reader) (string, error) {
	h := sha256.New()
	if _, err := io.Copy(h, r); err != nil {
		return "", err
	}

	return fmt.Sprintf("sha256-%x", h.Sum(nil)), nil
}

type recordPointer struct {
	OrgID        string    `json:"orgID"`
	DatasetID    string    `json:"datasetID"`
	FileName     string    `json:"fileName"`
	FileHash     string    `json:"fileHash"`
	Offset       int64     `json:"offset"`
	Length       int64     `json:"length"` // if length is zero read everything
	StartLine    int64     `json:"startLine"`
	Lines        int64     `json:"lines"`
	HubID        string    `json:"hubID"`
	LocalID      string    `json:"localID"`
	RecordHash   string    `json:"recordHash"`
	GraphName    string    `json:"graphName"`
	LastModified time.Time `json:"lastModified"`
	Deleted      bool      `json:"deleted"`
}

func (idx *index) Data(rp *recordPointer) (data []byte, err error) {
	r, err := idx.Reader(rp)
	if err != nil {
		return data, err
	}

	var buf bytes.Buffer

	if _, err = io.Copy(&buf, r); err != nil {
		return data, err
	}

	return buf.Bytes(), err
}

func (idx *index) Reader(rp *recordPointer) (r io.Reader, err error) {
	f, ok := idx.files[rp.FileName]
	if !ok {
		f, err = os.Open(rp.FileName)
		if err != nil {
			return r, err
		}

		idx.files[rp.FileName] = f
	}

	r = io.NewSectionReader(f, rp.Offset, rp.Length)

	return r, nil
}
